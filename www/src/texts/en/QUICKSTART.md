---
typora-root-url: ..\
---

This page shows how to add the `MtFmt` library to your project.

[toc]

# 1 Download

A simple way to download source files is that [click here](https://github.com/MtFmT-Lib/mtfmt/archive/refs/heads/master.zip). It will download the zip file from the main branch of the [GitHub repository](https://github.com/MtFmT-Lib/mtfmt). The other way is to install git and run the following command in your terminal, which is suitable for the professional developer.

```bash
git clone --depth=1 git@github.com:MtFmT-Lib/mtfmt.git
# or: https://github.com/MtFmT-Lib/mtfmt.git if you have not ssh key
```

You can add it to the git submodule also.

```bash
git submodule add git@github.com:MtFmT-Lib/mtfmt.git
```

# 2 Add to project

The two folders should be included in the archive file. The `src` folder including C source files is all implementations. And, the `inc` folder includes C header files and C++ wrapper header files. A reasonable approach is to create a new folder to contain the `inc` and the `src` directories and copy that into your project directory.

## 2.1 Keil IDE

Using the middleware package is an easy way to add to the Keil IDE. You can find them here. As an alternative option, you can add the sources and configure the including path manually.

### 2.1.1 Using the package

The middleware package was auto-generated by GitHub action.

TODO

### 2.1.2 Add sources manually

Firstly, download the library sources and select the "Add existing file to Source Group" option like in [Figure 2.1](#figure_2_1).

![Figure 2.1: Add existing file menu item](./img/keil_add_ext_src_nlfs.png)

Then, add all files in the folder `src` into your project.

![Figure 2.2: Add existing file to source group](./img/keil_add_ext_src_step2_nlfs.png)

Now you add all source files succeeded. The next step is that add the including directory. The preprocessor must know where the file locates in that the preprocessor of the C compiler will copy the header into the source file simply. To add that to the project, click the "Options for Target" button in the toolbar.

![Figure 2.3: The "Options for Target" button](./img/keil_opt_for_target_btn.png)

Then find the "C/C++" tab and click the "..." button on the right side of the edit box.

![Figure 2.4: Including path in keil](./img/keil_cxx_opt_tab.png)

And select the `inc` folder in the dialog.

![Figure 2.5: Add an including path item](./img/keil_cxx_add_inc_path_step2.png)

Finally, we must set the C99 standard.

![Figure 2.6: Select C99 standard](./img/keil_c_standard.png)

Now you completed this section! Click the "Build" button or press the `F7` key to build your project and check the output has not any errors. Then, you can [go to the next section](#section_3)!

## 2.2 CMake

The archive includes the CMake file. Using the [git submodule](https://git-scm.com/docs/git-submodule) is a good choice if you use that version control system. [Section 1](#section_1) shows how to add the library by git submodule. Otherwise, copy the file to a suitable directory first.

Then, append the following to your `CMakeLists.txt`. That adds the library directory to the build. See more details in the [CMake document](https://cmake.org/cmake/help/latest/command/add_subdirectory.html)

```cmake
# assume that you copy all files into "./mtfmt"
add_subdirectory(mtfmt)
```

Finally, add the including path manually because the `add_subdirectory` command append subdirectory to the build only.

```cmake
target_include_directories(your_target PRIVATE "./mtfmt/inc")
```

Now you completed this section. [Go to the next section](#section_3)!

# 3 Customization

The microcontroller has a different instruction set such as [ARM v6m](https://developer.arm.com/documentation/ddi0419/e/) or [ARM v7m](https://developer.arm.com/documentation/ddi0403/ee/). The different instruction set includes different data processing instructions and different architecture memory model. And for the microprocessor unit, or MPU that runs an operating system usually. The `MtFmt` library provides a series of macros for conditional compilation, that makes it possible to control the final generated instructions, control memory allocators, and so on.

## 3.1 Optional features

The following [table 3.1](#table_3_1) shows all available macros.

!table-caption: Table 3.1 available macros

| Macros                     | Default | Description                                           |
| -------------------------- | :-----: | ----------------------------------------------------- |
| `_MSTR_USE_HARDWARE_DIV`   |    0    | Enable to use hardware divider operator.              |
| `_MSTR_USE_MALLOC `        |    0    | Enable to use `malloc` instead build-in heap manager. |
| `_MSTR_RUNTIME_HEAP_ALIGN` |    4    | Specify the alignment of build-in heap manager.       |
| `_MSTR_USE_STD_IO`         |    0    | Enable to use `stdout` support.                       |

Define the macro equal to `1`  to enable it. Otherwise, the value is not equal to `1` or the macro is undefined means disabling it. 

## 3.2 Usage examples

TODO

# 4 Cooperate with RTOS

Data synchronization is very important in the multi-threading or multi-task system. The **built-in memory manager has no data synchronization**. That means you **cannot use that in those situations**.  Instead using the OS API to replace the built-in memory manager. It is recommended to follow the following guidelines.

* NO-OS: using the built-in heap manager. No changes are required.
* RTOS: using the memory manager API provided by OS. See more details in [section 4.2](#section_4_2).
* Others(Linux, Windows, etc.): using the language standard library. See more details in [section 4.1](#section_4_1).

## 4.1 Using language supports

The C standard library provides the heap manager function. Enable the macro `_MSTR_USE_MALLOC` to use the `malloc` and the `free` function instead built-in heap manager. [Go to the next section](#section_5)!

## 4.2 Using memory management API

Many RTOS like [FreeRTOS](https://www.freertos.org/) or [µC/OS](https://weston-embedded.com/micrium/overview) provides a thread-safe or task-safe memory manager. To replace the build-in heap manager with that, enable the macro `_MSTR_USE_MALLOC` first and find `./inc/mm_cfg.h`. The `_MSTR_MEM_ALLOC_FUNCTION` macro specifies the allocating memory function and holds the same type $\text{size\_t}\rightarrow\text{void}*$ of `malloc` in the C standard library. Likewise, the `_MSTR_MEM_FREE_FUNCTION` macro specifies the releasing memory function and holds the same type $\text{void}*\rightarrow\text{void}$ of `free`. By default, those macros will be defined as follows.

```c
#define _MSTR_MEM_ALLOC_FUNCTION(s) malloc(s)
#define _MSTR_MEM_FREE_FUNCTION(s)  free(s)
```

Adding those macros to the file `./inc/mm_cfg.h` will replace the default implementation.

```c
#if !defined(_INCLUDE_MM_CFG_H_)
#define _INCLUDE_MM_CFG_H_
#include <stdint.h>
// add the macro definitions to here or #include "your_configure.h"
...
#endif // _INCLUDE_MM_CFG_H_
```

### 4.2.1 FreeRTOS

The FreeRTOS provides five different memory manager tactics which can be found [here](https://freertos.org/a00111.html). The `pvPortMalloc` function is the instead version of `malloc` and the `vPortFree` function is the instead version of `free`. They have the same signature as the standard library function. So we can replace the function symbol directly as follows.

```c
// #include "freertos.h"
#define _MSTR_MEM_ALLOC_FUNCTION(s) pvPortMalloc(s)
#define _MSTR_MEM_FREE_FUNCTION(s)  vPortFree(s)
```

You can go to [section 5](#section_5) to view the demo.

### 4.2.2 µC/OS

The μC/OS provides API which can be found [here](https://micrium.atlassian.net/wiki/spaces/osiidoc/pages/163866/Memory+Management) is not the same as the standard library function. That means we must write two helper functions in a standard C source file and then add them into `mm_cfg.h`.

TODO

### 4.2.3 RT-Thread

The RT-Thread provides API is the same signature as the standard library which can be found [here](https://www.rt-thread.io/document/site/programming-manual/memory/memory/#allocate-and-release-memory-block).  So we can replace the function symbol directly as follows.

```c
// #include "rtthread.h"
#define _MSTR_MEM_ALLOC_FUNCTION(s) rt_malloc(s)
#define _MSTR_MEM_FREE_FUNCTION(s)  rt_free(s)
```

You can go to [section 5](#section_5) to view the demo.

### 4.2.4 Others

TODO

# 5 A simple demo

TODO
